
################################################################################
em = function(X, K, eps = 1e-6, maxiter = 1e5) {
# X: input data, with word counts for the N observations
# K: number of clusters of the latent variable
# eps: value that defines the distance at which the algorithm stabilizes
# maxiter: maximum number of iterations allowed before convergence
################################################################################  
  # Number of observations
  N = length(D)

  # Initialize parameters
  for (i in 1:N) {
    beta1[i] = [1 / v1, ..., 1 / V1]  # length V1
    beta2[i] = [1 / v2, ..., 1 / V2]  # length V2
  }
  B1 = [beta1[1], ..., beta1[N]]  # matrix with betas1
  B2 = [beta2[1], ..., beta2[N]]  # matrix with betas2
  rho = [1 / K, ..., 1 / K]  # length K

  # Perform iteration until convergence
  iter = 1
  repeat {
    # Expectation step
    zhat = compute[Equation (2); X, rho, B1, B2]
    Q = compute[Equation (1); X, rho, B1, B2]

    # Maximization step
    for (k in 1:K) {
      rho[k] = sum(zhat[1:N, k]) / sum(zhat[1:N, 1:K])  # Equation (9)
    }

    for (i in 1:N) {
      # Equation (10)
      for (v1 in 1:V1) {
        beta1[i, v1] = sum(zhat[1:N, k] * X[1:N, v1]) /
                       sum(zhat[1:N, k] * X[1:N, 1:V1])
      }

      # Equation (11)
      for (v2 in 1:V2) {
        beta1[i, v2] = sum(zhat[1:N, k] * X[1:N, v2]) /
                       sum(zhat[1:N, k] * X[1:N, 1:V2])
      }
    }

    # Update all parameters
    B1 = [beta1[1], ..., beta1[N]]  # matrix with betas1
    B2 = [beta2[1], ..., beta2[N]]  # matrix with betas2
    rho = [1 / K, ..., 1 / K]  # length K

    # If the parameters have stabilized, we stop
    if (norm(B1) < eps & norm(B2) < eps & norm(rho) < eps) {
      converged = TRUE
      break
    }

    # If the algorithm has not stabilized after lots of iterations, stop
    if (iter > maxiter) {
      converged = FALSE
      break
    }

    # Update iterator
    iter = iter + 1
  }

  # End
  return(zhat, B1, B2, rho, converged)
}




